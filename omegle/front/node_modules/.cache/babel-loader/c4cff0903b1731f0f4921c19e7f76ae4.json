{"ast":null,"code":"/* global module, require, console, __dirname */\n\n/**\n * Event listeners used by EasyRTC. Many of these can be overridden using server options.\n * \n * @module      easyrtc_default_event_listeners\n * @author      Priologic Software, info@easyrtc.com\n * @copyright   Copyright 2016 Priologic Software. All rights reserved.\n * @license     BSD v2, see LICENSE file in module root folder.\n */\nvar util = require(\"util\"); // General utility functions core module\n\n\nvar _ = require(\"underscore\"); // General utility functions external module\n\n\nvar g = require(\"./general_util\"); // General utility functions local module\n\n\nvar async = require(\"async\"); // Asynchronous calls external module\n\n\nvar pub = require(\"./easyrtc_public_obj\"); // EasyRTC public object\n\n/**\n * Event listeners used by EasyRTC. Many of these can be overridden using server options. The interfaces should be used as a guide for creating new listeners.\n *\n * @class \n */\n\n\nvar eventListener = module.exports;\n/**\n * Default listener for event \"authenticate\". This event is called as part of the authentication process. To deny authentication, call the next() with an Error. By default everyone gets in!\n * \n * @param       {Object} socket         Socket.io socket object. References the individual connection socket. \n * @param       {String} easyrtcid      Unique identifier for an EasyRTC connection.\n * @param       {string} appName        Application name which uniquely identifies it on the server.\n * @param       {?String} username      Username to assign to the connection.\n * @param       {?*} credential         Credential for the connection. Can be any JSONable object.\n * @param       {Object} easyrtcAuthMessage Message object containing the complete authentication message sent by the connection.\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\neventListener.onAuthenticate = function (socket, easyrtcid, appName, username, credential, easyrtcAuthMessage, next) {\n  next(null);\n};\n/**\n * Default listener for event \"authenticated\". This event is called after a connection is authenticated and the connection object is generated and requested rooms are joined. Call next(err) to continue the connection procedure.\n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onAuthenticated = function (connectionObj, next) {\n  next(null);\n};\n/**\n * Default listener for event \"connection\". This event is called when socket.io accepts a new connection.\n *\n * @param       {Object} socket         Socket.io socket object. References the individual connection socket. \n * @param       {String} easyrtcid      Unique identifier for an EasyRTC connection.\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onConnection = function (socket, easyrtcid, next) {\n  var connectionObj = {}; // prepare variables to house the connection object\n  // Initially upon a connection, we are only concerned with receiving an easyrtcAuth message\n\n  socket.on(\"easyrtcAuth\", function (msg, socketCallback) {\n    if (pub.getOption(\"logMessagesEnable\")) {\n      try {\n        pub.util.logDebug(\"[\" + easyrtcid + \"] Incoming socket.io message: [\" + JSON.stringify(msg) + \"]\");\n      } catch (err) {\n        pub.util.logDebug(\"[\" + easyrtcid + \"] Incoming socket.io message\");\n      }\n    }\n\n    pub.events.emit(\"easyrtcAuth\", socket, easyrtcid, msg, socketCallback, function (err, newConnectionObj) {\n      if (err) {\n        pub.util.logError(\"[\" + easyrtcid + \"] Unhandled easyrtcCmd listener error.\", err);\n        return;\n      }\n\n      connectionObj = newConnectionObj;\n    });\n  });\n  pub.util.logDebug(\"Running func 'onConnection'\");\n  next(null);\n};\n/**\n * Default listener for event \"disconnect\". This event is called when socket.io detects a disconnection. Disconnections can occur due to either side purposefully dropping a connection, network disconnection, or time out. \n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onDisconnect = function (connectionObj, next) {\n  pub.util.logDebug(\"Running func 'onDisconnect'\");\n  async.waterfall([function (asyncCallback) {\n    // Get array of rooms\n    connectionObj.getRoomNames(asyncCallback);\n  }, function (roomNames, asyncCallback) {\n    // leave all rooms\n    async.each(roomNames, function (currentRoomName, asyncEachCallback) {\n      pub.events.emit(\"roomLeave\", connectionObj, currentRoomName, function (err) {\n        asyncEachCallback(null);\n      });\n    }, function (err) {\n      asyncCallback(null);\n    });\n  }, function (asyncCallback) {\n    // log all connections as ended\n    pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Disconnected\");\n    connectionObj.removeConnection(asyncCallback);\n  }], function (err) {\n    next(null);\n  });\n  next(null);\n};\n/**\n * Default listener for event \"easyrtcAuth\". This event is fired when an incoming 'easyrtcAuth' message is received from a client.\n *\n * @param       {Object}    socket         Socket.io socket object. References the individual connection socket.\n * @param       {String}    easyrtcid      Unique identifier for an EasyRTC connection.\n * @param       {Object}    msg            Message object which contains the full message from a client; this can include the standard msgType and msgData fields.\n * @param       {Function}  socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {Function}  callback       Callback to call upon completion. Delivers parameter (err, connectionObj).\n */\n\n\neventListener.onEasyrtcAuth = function (socket, easyrtcid, msg, socketCallback, callback) {\n  pub.util.logDebug(\"[\" + easyrtcid + \"] Running func 'onEasyrtcAuth'\");\n  var appObj, connectionObj, sessionObj; // prepare variables to house the application, connection, and session objects\n\n  var tokenMsg = {\n    msgType: \"token\",\n    msgData: {}\n  };\n  var appName;\n  var newAppName = _.isObject(msg.msgData) && _.isString(msg.msgData.applicationName) ? msg.msgData.applicationName : pub.getOption(\"appDefaultName\"); // Ensure socketCallback is present\n\n  if (!_.isFunction(socketCallback)) {\n    pub.util.logWarning(\"[\" + easyrtcid + \"] EasyRTC Auth message received with no callback. Disconnecting socket.\", msg);\n\n    try {\n      socket.disconnect();\n    } catch (e) {}\n\n    return;\n  } // Only accept authenticate message\n\n\n  if (!_.isObject(msg) || !_.isString(msg.msgType) || msg.msgType != \"authenticate\") {\n    pub.util.logWarning(\"[\" + easyrtcid + \"] EasyRTC Auth message received without msgType of 'authenticate'. Disconnecting socket.\", msg);\n    pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"LOGIN_BAD_AUTH\"), appObj);\n\n    try {\n      socket.disconnect();\n    } catch (e) {}\n\n    return;\n  } // Check msg structure.\n\n\n  if (!_.isObject(msg.msgData) || !_.isString(msg.msgData.apiVersion) || msg.msgData.roomJoin !== undefined && !_.isObject(msg.msgData.roomJoin)) {\n    pub.util.logWarning(\"[\" + easyrtcid + \"] EasyRTC Auth message received with improper msgData. Disconnecting socket.\", msg);\n    pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"LOGIN_BAD_STRUCTURE\"), appObj);\n\n    try {\n      socket.disconnect();\n    } catch (e) {}\n\n    return;\n  }\n\n  async.waterfall([function (asyncCallback) {\n    // Check message structure\n    pub.util.isValidIncomingMessage(\"easyrtcAuth\", msg, null, asyncCallback);\n  }, function (isMsgValid, msgErrorCode, asyncCallback) {\n    // If message structure is invalid, send error, disconnect socket, and write to log\n    if (!isMsgValid) {\n      try {\n        pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(msgErrorCode), appObj);\n        socket.disconnect();\n      } catch (e) {}\n\n      pub.util.logWarning(\"[\" + easyrtcid + \"] EasyRTC Auth message received with invalid message format [\" + msgErrorCode + \"]. Disconnecting socket.\", msg);\n      callback(new pub.util.ConnectionError(\"[\" + easyrtcid + \"] EasyRTC Auth message received with invalid message format [\" + msgErrorCode + \"]. Disconnecting socket.\"));\n      return;\n    } // Remove any old listeners\n\n\n    socket.removeAllListeners(\"easyrtcCmd\");\n    socket.removeAllListeners(\"easyrtcMsg\");\n    socket.removeAllListeners(\"disconnect\"); // TODO: Come up with alternative to removing all disconnect listeners\n\n    pub.util.logDebug(\"Emitting Authenticate\");\n    var username = msg.msgData.username ? msg.msgData.username : null;\n    var credential = msg.msgData.credential ? msg.msgData.credential : null; // Authenticate is responsible for authenticating the connection\n\n    pub.events.emit(\"authenticate\", socket, easyrtcid, newAppName, username, credential, msg, function (err) {\n      if (err) {\n        try {\n          pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"LOGIN_BAD_AUTH\"), appObj);\n          socket.disconnect();\n          pub.util.logInfo(\"[\" + newAppName + \"][\" + easyrtcid + \"] Authentication denied. Socket disconnected.\", err);\n        } catch (e) {}\n      } else {\n        asyncCallback(null);\n      }\n    });\n  }, function (asyncCallback) {\n    // Check to see if the requested app currently exists.\n    pub.isApp(newAppName, asyncCallback);\n  }, function (isApp, asyncCallback) {\n    // If requested app exists, then call it, otherwise create it.\n    if (isApp) {\n      pub.app(newAppName, asyncCallback);\n    } else {\n      // if appAutoCreateEnable is true, then a new app will be created using the default options\n      if (pub.getOption(\"appAutoCreateEnable\")) {\n        pub.createApp(newAppName, null, asyncCallback);\n      } else {\n        pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"LOGIN_APP_AUTH_FAIL\"), appObj);\n        socket.disconnect();\n        pub.util.logWarning(\"[\" + easyrtcid + \"] Authentication failed. Requested application not found [\" + newAppName + \"]. Socket disconnected.\");\n      }\n    }\n  }, function (newAppObj, asyncCallback) {\n    // Now that we have an app, we can use it\n    appObj = newAppObj;\n    appName = appObj.getAppName();\n    appObj.isConnected(easyrtcid, asyncCallback);\n  }, function (isConnected, asyncCallback) {\n    // If socket has previously connected, disconnect them.\n    if (isConnected) {\n      pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"LOGIN_APP_AUTH_FAIL\"), appObj);\n      socket.disconnect();\n      pub.util.logWarning(\"[\" + easyrtcid + \"] Authentication failed. Already connected. Socket disconnected.\");\n      return;\n    } // if roomJoin is present in message, check the room names\n\n\n    if (msg.msgData.roomJoin) {\n      for (var currentRoomName in msg.msgData.roomJoin) {\n        if (!_.isString(currentRoomName) || !appObj.getOption(\"roomNameRegExp\").test(currentRoomName)) {\n          pub.events.emit(\"emitReturnError\", socketCallback, \"MSG_REJECT_TARGET_ROOM\", pub.util.nextToNowhere);\n          pub.util.logInfo(\"[\" + easyrtcid + \"] Authentication failed. Requested room name not allowed [\" + currentRoomName + \"].\");\n          return;\n        }\n      }\n    }\n\n    asyncCallback(null);\n  }, function (asyncCallback) {\n    // Create the connection object\n    appObj.createConnection(easyrtcid, socket.id, asyncCallback);\n  }, function (newConnectionObj, asyncCallback) {\n    connectionObj = newConnectionObj; // Check if there is an easyrtcsid\n\n    if (_.isString(msg.msgData.easyrtcsid)) {\n      appObj.isSession(msg.msgData.easyrtcsid, function (err, isSession) {\n        if (err) {\n          asyncCallback(err);\n          return;\n        }\n\n        if (isSession) {\n          appObj.session(msg.msgData.easyrtcsid, asyncCallback);\n        } else {\n          appObj.createSession(msg.msgData.easyrtcsid, asyncCallback);\n        }\n      });\n    } else {\n      asyncCallback(null, null);\n    }\n  }, function (newSessionObj, asyncCallback) {\n    if (!newSessionObj) {\n      asyncCallback(null);\n      return;\n    }\n\n    sessionObj = newSessionObj;\n    connectionObj.joinSession(sessionObj.getEasyrtcsid(), asyncCallback);\n  }, function (asyncCallback) {\n    // Set connection as being authenticated (we pre-authenticated)\n    connectionObj.setAuthenticated(true, asyncCallback);\n  }, function (asyncCallback) {\n    // Set username (if defined)\n    if (msg.msgData.username !== undefined) {\n      connectionObj.setUsername(msg.msgData.username, asyncCallback);\n    } else {\n      asyncCallback(null);\n    }\n  }, function (asyncCallback) {\n    // Set credential (if defined)\n    if (msg.msgData.username !== undefined) {\n      connectionObj.setCredential(msg.msgData.credential, asyncCallback);\n    } else {\n      asyncCallback(null);\n    }\n  }, function (asyncCallback) {\n    // Set presence (if defined)\n    if (_.isObject(msg.msgData.setPresence)) {\n      connectionObj.setPresence(msg.msgData.setPresence, asyncCallback);\n    } else {\n      asyncCallback(null);\n    }\n  }, function (asyncCallback) {\n    // Join a room. If no rooms are defined than join the default room\n    if (_.isObject(msg.msgData.roomJoin) && !_.isEmpty(msg.msgData.roomJoin)) {\n      async.each(Object.keys(msg.msgData.roomJoin), function (currentRoomName, roomCallback) {\n        appObj.isRoom(currentRoomName, function (err, isRoom) {\n          if (err) {\n            roomCallback(err);\n            return;\n          } // Set roomParameter map. This may be used by custom listeners.\n\n\n          var currentRoomParameter;\n\n          if (msg.msgData.roomJoin[currentRoomName] && _.isObject(msg.msgData.roomJoin[currentRoomName].roomParameter)) {\n            currentRoomParameter = msg.msgData.roomJoin[currentRoomName].roomParameter;\n          }\n\n          if (isRoom) {\n            // Join existing room\n            pub.events.emit(\"roomJoin\", connectionObj, currentRoomName, currentRoomParameter, roomCallback);\n          } else if (appObj.getOption(\"roomAutoCreateEnable\")) {\n            // Room doesn't yet exist, however we are allowed to create it.\n            pub.events.emit(\"roomCreate\", appObj, connectionObj, currentRoomName, null, function (err, roomObj) {\n              if (err) {\n                roomCallback(err);\n                return;\n              }\n\n              pub.events.emit(\"roomJoin\", connectionObj, currentRoomName, currentRoomParameter, roomCallback);\n            });\n          } else {\n            // Can't join room and we are not allowed to create it. Error Out.\n            try {\n              pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"LOGIN_BAD_ROOM\"), appObj);\n              socket.disconnect();\n            } catch (e) {}\n\n            pub.util.logInfo(\"[\" + easyrtcid + \"] Authentication failed. Requested room name does not exist [\" + currentRoomName + \"].\");\n          }\n        });\n      }, function (err, newRoomObj) {\n        asyncCallback(err);\n      });\n    } // If no room is initially provided, have them join the default room (if enabled)\n    else if (connectionObj.getApp().getOption(\"roomDefaultEnable\")) {\n        pub.events.emit(\"roomJoin\", connectionObj, connectionObj.getApp().getOption(\"roomDefaultName\"), null, function (err, roomObj) {\n          asyncCallback(err);\n        });\n      } // No room provided, and can't join default room\n      else {\n          asyncCallback(null);\n        }\n  }, function (asyncCallback) {\n    // Add new listeners\n    socket.on(\"easyrtcCmd\", function (msg, socketCallback) {\n      if (pub.getOption(\"logMessagesEnable\")) {\n        try {\n          pub.util.logDebug(\"[\" + appName + \"][\" + easyrtcid + \"] Incoming socket.io message: [\" + JSON.stringify(msg) + \"]\");\n        } catch (err) {\n          pub.util.logDebug(\"[\" + appName + \"][\" + easyrtcid + \"] Incoming socket.io message\");\n        }\n      }\n\n      pub.events.emit(\"easyrtcCmd\", connectionObj, msg, socketCallback, function (err) {\n        if (err) {\n          pub.util.logError(\"[\" + appName + \"][\" + easyrtcid + \"] Unhandled easyrtcCmd listener error.\", err);\n        }\n      });\n    });\n    socket.on(\"easyrtcMsg\", function (msg, socketCallback) {\n      if (pub.getOption(\"logMessagesEnable\")) {\n        try {\n          pub.util.logDebug(\"[\" + appName + \"][\" + easyrtcid + \"] Incoming socket.io message: [\" + JSON.stringify(msg) + \"]\");\n        } catch (err) {\n          pub.util.logDebug(\"[\" + appName + \"][\" + easyrtcid + \"] Incoming socket.io message\");\n        }\n      }\n\n      pub.events.emit(\"easyrtcMsg\", connectionObj, msg, socketCallback, function (err) {\n        if (err) {\n          pub.util.logError(\"[\" + appName + \"][\" + easyrtcid + \"] Unhandled easyrtcMsg listener error.\", err);\n        }\n      });\n    });\n    socket.on(\"disconnect\", function () {\n      pub.events.emit(\"disconnect\", connectionObj, function (err) {\n        if (err) {\n          pub.util.logError(\"[\" + appName + \"][\" + easyrtcid + \"] Unhandled disconnect listener error.\", err);\n        }\n      });\n    });\n    asyncCallback(null);\n  }, function (asyncCallback) {\n    pub.events.emit(\"authenticated\", connectionObj, asyncCallback);\n  }, function (asyncCallback) {\n    pub.events.emit(\"emitReturnToken\", connectionObj, socketCallback, asyncCallback);\n  }, function (asyncCallback) {\n    // TODO: Reinstate this emit function by setting flag for roomJoin event so it doesn't automatically emit delta's\n    // Emit clientList delta to other clients in room\n    // connectionObj.emitRoomDataDelta(false, function(err, roomDataObj){asyncCallback(err);});\n    asyncCallback(null);\n  }], // This function is called upon completion of the async waterfall, or upon an error being thrown.\n  function (err) {\n    if (err) {\n      try {\n        pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"LOGIN_GEN_FAIL\"), appObj);\n        socket.disconnect();\n        pub.util.logError(\"[\" + easyrtcid + \"] General authentication error. Socket disconnected.\", err);\n      } catch (e) {}\n    } else {\n      callback(null, connectionObj);\n    }\n  });\n};\n/**\n * Default listener for event \"easyrtcCmd\". This event is fired when an incoming 'easyrtcCmd' message is received from a client.\n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Object} msg            Message object which contains the full message from a client; this can include the standard msgType and msgData fields.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onEasyrtcCmd = function (connectionObj, msg, socketCallback, next) {\n  var appName = connectionObj.getAppName();\n  var appObj = connectionObj.getApp();\n  var easyrtcid = connectionObj.getEasyrtcid();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC command received with msgType [\" + msg.msgType + \"]\");\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  if (!_.isFunction(socketCallback)) {\n    pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC command message received with no callback. Ignoring.\", msg);\n    return;\n  }\n\n  async.waterfall([function (asyncCallback) {\n    // Check message structure\n    pub.util.isValidIncomingMessage(\"easyrtcCmd\", msg, connectionObj.getApp(), asyncCallback);\n  }, function (isMsgValid, msgErrorCode, asyncCallback) {\n    // If message structure is invalid, send error, and write to log\n    if (!isMsgValid) {\n      try {\n        pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(msgErrorCode), appObj);\n      } catch (e) {}\n\n      pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC Auth message received with invalid message format [\" + msgErrorCode + \"]. Disconnecting socket.\", msg);\n      return;\n    }\n\n    asyncCallback(null);\n  }, function (asyncCallback) {\n    // The msgType controls how each message is handled\n    switch (msg.msgType) {\n      case \"setUserCfg\":\n        pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] WebRTC setUserCfg command received. This feature is not yet complete.\");\n        pub.util.sendSocketCallbackAck(easyrtcid, socketCallback, appObj);\n        next(null);\n        break;\n\n      case \"setPresence\":\n        pub.events.emit(\"msgTypeSetPresence\", connectionObj, msg.msgData.setPresence, socketCallback, next);\n        break;\n\n      case \"setRoomApiField\":\n        pub.events.emit(\"msgTypeSetRoomApiField\", connectionObj, msg.msgData.setRoomApiField, socketCallback, next);\n        break;\n\n      case \"roomJoin\":\n        pub.events.emit(\"msgTypeRoomJoin\", connectionObj, msg.msgData.roomJoin, socketCallback, next);\n        break;\n\n      case \"roomLeave\":\n        pub.events.emit(\"msgTypeRoomLeave\", connectionObj, msg.msgData.roomLeave, socketCallback, next);\n        break;\n\n      case \"getIceConfig\":\n        pub.events.emit(\"msgTypeGetIceConfig\", connectionObj, socketCallback, next);\n        break;\n\n      case \"getRoomList\":\n        pub.events.emit(\"msgTypeGetRoomList\", connectionObj, socketCallback, next);\n        break;\n\n      case \"candidate\":\n      case \"offer\":\n      case \"answer\":\n      case \"reject\":\n      case \"hangup\":\n        // Relay message to targetEasyrtcid\n        var outgoingMsg = {\n          senderEasyrtcid: connectionObj.getEasyrtcid(),\n          msgData: msg.msgData\n        };\n        connectionObj.getApp().connection(msg.targetEasyrtcid, function (err, targetConnectionObj) {\n          if (err) {\n            pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_TARGET_EASYRTCID\"), appObj);\n            pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Could not send WebRTC signal to client [\" + msg.targetEasyrtcid + \"]. They may no longer be online.\");\n            return;\n          }\n\n          pub.events.emit(\"emitEasyrtcCmd\", targetConnectionObj, msg.msgType, outgoingMsg, null, next);\n          pub.util.sendSocketCallbackAck(easyrtcid, socketCallback, appObj);\n          next(null);\n        });\n        break;\n\n      default:\n        pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_BAD_TYPE\"), appObj);\n        pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Received easyrtcCmd message with unhandled msgType.\", msg);\n        next(null);\n    }\n  }], function (err) {\n    if (err) {\n      try {\n        pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_GEN_FAIL\"), appObj);\n        pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Received easyrtcCmd message with general error.\", msg);\n      } catch (e) {}\n    }\n  });\n};\n/**\n * Default listener for event \"easyrtcMsg\". This event is fired when an incoming 'easyrtcMsg' message is received from a client.\n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Object} msg            Message object which contains the full message from a client; this can include the standard msgType and msgData fields.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onEasyrtcMsg = function (connectionObj, msg, socketCallback, next) {\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appObj = connectionObj.getApp();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC message received of type [\" + msg.msgType + \"]\");\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  if (!_.isFunction(socketCallback)) {\n    pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC message received with no callback. Ignoring message.\", msg);\n    return;\n  }\n\n  async.waterfall([function (asyncCallback) {\n    // Check message structure\n    pub.util.isValidIncomingMessage(\"easyrtcMsg\", msg, connectionObj.getApp(), asyncCallback);\n  }, function (isMsgValid, msgErrorCode, asyncCallback) {\n    // If message structure is invalid, send error, and write to log\n    if (!isMsgValid) {\n      pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(msgErrorCode), appObj);\n      pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC message received with invalid message format [\" + msgErrorCode + \"].\", msg);\n      return;\n    }\n\n    asyncCallback(null);\n  }, function (asyncCallback) {\n    // test targetEasyrtcid (if defined). Will prevent client from sending to themselves\n    if (msg.targetEasyrtcid !== undefined && msg.targetEasyrtcid == connectionObj.getEasyrtcid()) {\n      pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_TARGET_EASYRTCID\"), appObj);\n      pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC message received with improper targetEasyrtcid\", msg);\n      return;\n    } // Determine if sending message to single client, an entire room, or an entire group\n\n\n    if (msg.targetEasyrtcid !== undefined) {\n      // Relay a message to a single client\n      var outgoingMsg = {\n        senderEasyrtcid: connectionObj.getEasyrtcid(),\n        targetEasyrtcid: msg.targetEasyrtcid,\n        msgType: msg.msgType,\n        msgData: msg.msgData\n      };\n      var targetConnectionObj = {};\n      async.waterfall([function (asyncCallback) {\n        // getting connection object for targetEasyrtcid\n        connectionObj.getApp().connection(msg.targetEasyrtcid, asyncCallback);\n      }, function (newTargetConnectionObj, asyncCallback) {\n        targetConnectionObj = newTargetConnectionObj; // TODO: Add option to restrict users not in same room from sending messages to users in room\n        // Handle targetRoom (if present)\n\n        if (msg.targetRoom) {\n          targetConnectionObj.isInRoom(msg.targetRoom, function (err, isAllowed) {\n            if (err || !isAllowed) {\n              pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_TARGET_ROOM\"), appObj);\n              pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC message received with improper target room\", msg);\n              return;\n            }\n\n            outgoingMsg.targetRoom = msg.targetRoom;\n            asyncCallback(null);\n          });\n        } else {\n          asyncCallback(null);\n        }\n      }, function (asyncCallback) {\n        // Handle targetGroup (if present)\n        if (msg.targetGroup) {\n          targetConnectionObj.isInGroup(msg.targetGroup, function (err, isAllowed) {\n            if (err || !isAllowed) {\n              pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_TARGET_GROUP\"), appObj);\n              pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC message received with improper target group\", msg);\n              return;\n            }\n\n            outgoingMsg.targetGroup = msg.targetGroup;\n            asyncCallback(null);\n          });\n        } else {\n          asyncCallback(null);\n        }\n      }, function (asyncCallback) {\n        pub.events.emit(\"emitEasyrtcMsg\", targetConnectionObj, msg.msgType, outgoingMsg, null, asyncCallback);\n      }], function (err) {\n        if (err) {\n          pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_GEN_FAIL\"), appObj);\n          pub.util.logError(\"[\" + connectionObj.getEasyrtcid() + \"] General message error. Message ignored.\", err);\n        } else {\n          pub.util.sendSocketCallbackAck(easyrtcid, socketCallback, appObj);\n        }\n      });\n    } else if (msg.targetRoom) {\n      // Relay a message to one or more clients in a room\n      var outgoingMsg = {\n        senderEasyrtcid: connectionObj.getEasyrtcid(),\n        targetRoom: msg.targetRoom,\n        msgType: msg.msgType,\n        msgData: msg.msgData\n      };\n      var targetRoomObj = null;\n      async.waterfall([function (asyncCallback) {\n        // get room object\n        connectionObj.getApp().room(msg.targetRoom, asyncCallback);\n      }, function (newTargetRoomObj, asyncCallback) {\n        targetRoomObj = newTargetRoomObj; // get list of connections in the room\n\n        targetRoomObj.getConnections(asyncCallback);\n      }, function (connectedEasyrtcidArray, asyncCallback) {\n        for (var i = 0; i < connectedEasyrtcidArray.length; i++) {\n          // Stop client from sending message to themselves\n          if (connectedEasyrtcidArray[i] == connectionObj.getEasyrtcid()) {\n            continue;\n          }\n\n          connectionObj.getApp().connection(connectedEasyrtcidArray[i], function (err, targetConnectionObj) {\n            if (err) {\n              return;\n            } // Do we limit by group? If not the message goes out to all in room\n\n\n            if (msg.targetGroup) {\n              targetConnectionObj.isInGroup(msg.targetGroup, function (err, isAllowed) {\n                if (isAllowed) {\n                  pub.events.emit(\"emitEasyrtcMsg\", targetConnectionObj, msg.msgType, outgoingMsg, null, pub.util.nextToNowhere);\n                }\n              });\n            } else {\n              pub.events.emit(\"emitEasyrtcMsg\", targetConnectionObj, msg.msgType, outgoingMsg, null, pub.util.nextToNowhere);\n            }\n          });\n        }\n\n        asyncCallback(null);\n      }], function (err) {\n        if (err) {\n          pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_TARGET_ROOM\"), appObj);\n        } else {\n          pub.util.sendSocketCallbackAck(easyrtcid, socketCallback, appObj);\n        }\n      });\n    } else if (msg.targetGroup) {\n      // Relay a message to one or more clients in a group\n      var targetGroupObj = null;\n      var outgoingMsg = {\n        senderEasyrtcid: connectionObj.getEasyrtcid(),\n        targetGroup: msg.targetGroup,\n        msgType: msg.msgType,\n        msgData: msg.msgData\n      };\n      async.waterfall([function (asyncCallback) {\n        // get group object\n        connectionObj.getApp().group(msg.targetGroup, asyncCallback);\n      }, function (newTargetGroupObj, asyncCallback) {\n        targetGroupObj = newTargetGroupObj; // get list of connections in the group\n\n        targetGroupObj.getConnections(asyncCallback);\n      }, function (connectedEasyrtcidArray, asyncCallback) {\n        for (var i = 0; i < connectedEasyrtcidArray.length; i++) {\n          // Stop client from sending message to themselves\n          if (connectedEasyrtcidArray[i] == connectionObj.getEasyrtcid()) {\n            continue;\n          }\n\n          connectionObj.getApp().connection(connectedEasyrtcidArray[i], function (err, targetConnectionObj) {\n            if (err) {\n              return;\n            }\n\n            pub.events.emit(\"emitEasyrtcMsg\", targetConnectionObj, msg.msgType, outgoingMsg, null, pub.util.nextToNowhere);\n          });\n        }\n\n        asyncCallback(null);\n      }], function (err) {\n        if (err) {\n          pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_TARGET_GROUP\"), appObj);\n        } else {\n          pub.util.sendSocketCallbackAck(easyrtcid, socketCallback, appObj);\n        }\n      });\n    } else {\n      pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC message received without targetEasyrtcid or targetRoom\", msg);\n      next(null);\n    }\n  }], function (err) {\n    if (err) {\n      pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_GEN_FAIL\"), appObj);\n      pub.util.logError(\"[\" + connectionObj.getEasyrtcid() + \"] General message error. Message ignored.\", err);\n    }\n  });\n};\n/**\n * Default listener for event \"emitEasyrtcCmd\". This event is fired when the server should emit an EasyRTC command to a client.\n * \n * The easyrtcid and serverTime fields will be added to the msg automatically.\n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {String} msgType        Message type of the message.\n * @param       {Object} msg            Message object which contains the full message to a client; this can include the standard msgData field.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onEmitEasyrtcCmd = function (connectionObj, msgType, msg, socketCallback, next) {\n  if (!_.isObject(connectionObj)) {\n    next(new pub.util.ConnectionError(\"Connection object invalid. Client may have disconnected.\"));\n    return;\n  }\n\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appName = connectionObj.getAppName();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onEmitEasyrtcCmd' with msgType [\" + msgType + \"]\");\n\n  if (!msg) {\n    msg = {};\n  }\n\n  if (!_.isFunction(socketCallback)) {\n    socketCallback = function (returnMsg) {\n      if (_.isObject(returnMsg) && _.isString(returnMsg.msgType) && returnMsg.msgType == \"ack\") {// pub.util.logDebug(\"[\"+connectionObj.getAppName()+\"][\"+connectionObj.getEasyrtcid()+\"] EasyRTC message: unhandled Ack return message.\");\n      } else {\n        pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC message: unhandled return message.\", returnMsg);\n      }\n    };\n  }\n\n  msg.easyrtcid = connectionObj.getEasyrtcid();\n  msg.msgType = msgType;\n  msg.serverTime = Date.now();\n  connectionObj.socket.emit(\"easyrtcCmd\", msg, socketCallback);\n\n  if (pub.getOption(\"logMessagesEnable\")) {\n    try {\n      pub.util.logDebug(\"[\" + appName + \"][\" + easyrtcid + \"] Sending socket.io message: [\" + JSON.stringify(msg) + \"]\");\n    } catch (err) {\n      pub.util.logDebug(\"[\" + appName + \"][\" + easyrtcid + \"] Sending socket.io message\");\n    }\n  }\n\n  next(null);\n};\n/**\n * Default listener for event \"emitEasyrtcMsg\". This event is fired when the server should emit an EasyRTC message to a client.\n * \n * The easyrtcid and serverTime fields will be added to the msg automatically.\n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {String} msgType        Message type of the message.\n * @param       {Object} msg            Message object which contains the full message to a client; this can include the standard msgData field.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onEmitEasyrtcMsg = function (connectionObj, msgType, msg, socketCallback, next) {\n  if (!_.isObject(connectionObj)) {\n    next(new pub.util.ConnectionError(\"Connection object invalid. Client may have disconnected.\"));\n    return;\n  }\n\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appName = connectionObj.getAppName();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onEmitEasyrtcMsg' with msgType [\" + msgType + \"]\");\n\n  if (!msg) {\n    msg = {};\n  }\n\n  if (!_.isFunction(socketCallback)) {\n    socketCallback = function (returnMsg) {\n      if (_.isObject(returnMsg) && _.isString(returnMsg.msgType) && returnMsg.msgType == \"ack\") {// pub.util.logDebug(\"[\"+connectionObj.getAppName()+\"][\"+connectionObj.getEasyrtcid()+\"] EasyRTC message: unhandled Ack return message.\");\n      } else {\n        pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC message: unhandled return message.\", returnMsg);\n      }\n    };\n  }\n\n  msg.easyrtcid = connectionObj.getEasyrtcid();\n  msg.msgType = msgType;\n  msg.serverTime = Date.now();\n  connectionObj.socket.emit(\"easyrtcMsg\", msg, socketCallback);\n\n  if (pub.getOption(\"logMessagesEnable\")) {\n    try {\n      pub.util.logDebug(\"[\" + appName + \"][\" + easyrtcid + \"] Sending socket.io message: [\" + JSON.stringify(msg) + \"]\");\n    } catch (err) {\n      pub.util.logDebug(\"[\" + appName + \"][\" + easyrtcid + \"] Sending socket.io message\");\n    }\n  }\n\n  next(null);\n};\n/**\n * Default listener for event \"emitError\". This event is fired when the server should emit an EasyRTC error to a client.\n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {String} errorCode      EasyRTC error code associated with an error.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onEmitError = function (connectionObj, errorCode, socketCallback, next) {\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onEmitError'\");\n\n  if (!_.isFunction(socketCallback)) {\n    socketCallback = function (returnMsg) {\n      pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC info: unhandled ACK return message.\", returnMsg);\n    };\n  }\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  pub.events.emit(\"emitEasyrtcCmd\", connectionObj, \"error\", pub.util.getErrorMsg(errorCode), socketCallback, next);\n};\n/**\n * Default listener for event \"emitReturnAck\". This event is fired when the server should return an Ack to a client via an acknowledgment message.\n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onEmitReturnAck = function (connectionObj, socketCallback, next) {\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appObj = connectionObj.getApp();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onEmitReturnAck'\");\n\n  if (!_.isFunction(socketCallback)) {\n    pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC: unable to return ack to socket.\");\n    return;\n  }\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  var msg = {\n    msgType: \"ack\",\n    msgData: {}\n  };\n  pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, msg, appObj);\n  next(null);\n};\n/**\n * Default listener for event \"emitReturnError\". This event is fired when the server should return an Error to a client via an acknowledgment message.\n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {String} errorCode      EasyRTC error code associated with an error.\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onEmitReturnError = function (connectionObj, socketCallback, errorCode, next) {\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appObj = connectionObj.getApp();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onEmitReturnError'\");\n\n  if (!_.isFunction(socketCallback)) {\n    pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC: unable to return error to socket. Error code was [\" + errorCode + \"]\");\n    next(new pub.util.ConnectionError(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Unable to return error to socket. Error code was [\" + errorCode + \"]\"));\n    return;\n  }\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  var msg = pub.util.getErrorMsg(errorCode);\n  pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, msg, appObj);\n  next(null);\n};\n/**\n * Default listener for event \"emitReturnToken\". This event is fired when the server should return a token to a client via an acknowledgment message.\n * \n * This is done after a client has been authenticated and the connection has been established.\n *\n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onEmitReturnToken = function (connectionObj, socketCallback, next) {\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appObj = connectionObj.getApp();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onSendToken'\");\n  var tokenMsg = {\n    msgType: \"token\",\n    msgData: {}\n  }; // Ensure socketCallback is present\n\n  if (!_.isFunction(socketCallback)) {\n    pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC onSendToken called with no socketCallback.\");\n\n    try {\n      connectionObj.socket.disconnect();\n    } catch (e) {}\n\n    return;\n  }\n\n  async.waterfall([function (asyncCallback) {\n    // Get rooms user is in along with list\n    connectionObj.generateRoomClientList(\"join\", null, asyncCallback);\n  }, function (roomData, asyncCallback) {\n    // Set roomData\n    tokenMsg.msgData.roomData = roomData; // Retrieve ice config\n\n    connectionObj.events.emit(\"getIceConfig\", connectionObj, asyncCallback);\n  }, function (iceServers, asyncCallback) {\n    tokenMsg.msgData.application = {\n      applicationName: connectionObj.getAppName()\n    };\n    tokenMsg.msgData.easyrtcid = connectionObj.getEasyrtcid();\n    tokenMsg.msgData.iceConfig = {\n      iceServers: iceServers\n    };\n    tokenMsg.msgData.serverTime = Date.now();\n    easyrtcid = tokenMsg.msgData.easyrtcid; // Get Application fields\n\n    appObj.getFields(true, asyncCallback);\n  }, function (fieldObj, asyncCallback) {\n    if (!_.isEmpty(fieldObj)) {\n      tokenMsg.msgData.application.field = fieldObj;\n    } // Get Connection fields\n\n\n    connectionObj.getFields(true, asyncCallback);\n  }, function (fieldObj, asyncCallback) {\n    if (!_.isEmpty(fieldObj)) {\n      tokenMsg.msgData.field = fieldObj;\n    } // get session object\n\n\n    connectionObj.getSessionObj(asyncCallback);\n  }, function (sessionObj, asyncCallback) {\n    if (sessionObj) {\n      tokenMsg.msgData.sessionData = {\n        \"easyrtcsid\": sessionObj.getEasyrtcsid()\n      }; // Get session fields\n\n      sessionObj.getFields(true, asyncCallback);\n    } else {\n      asyncCallback(null, null);\n    }\n  }, function (fieldObj, asyncCallback) {\n    // Set session field (if present)\n    if (fieldObj && !_.isEmpty(fieldObj)) {\n      tokenMsg.msgData.sessionData.field = fieldObj;\n    } // Emit token back to socket (SUCCESS!)\n\n\n    pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, tokenMsg, appObj);\n    asyncCallback(null);\n  }], // This function is called upon completion of the async waterfall, or upon an error being thrown.\n  function (err) {\n    if (err) {\n      next(err);\n    } else {\n      next(null);\n    }\n  });\n};\n/**\n * Default listener for event \"log\". This event is fired when ever a loggable item is observed.\n * \n * @param       {string} level          Log severity level. Can be (\"debug\"|\"info\"|\"warning\"|\"error\")\n * @param       {string} logText        Text for log.\n * @param       {?*} [logFields]        Simple JSON object which contains extra fields to be logged.\n * @param       {?nextCallback} next    A success callback of form next(err).\n */\n\n\neventListener.onLog = function (level, logText, logFields, next) {\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  var consoleText = \"\";\n  var currentDate = new Date();\n\n  if (pub.getOption(\"logColorEnable\")) {\n    var colors = require(\"colors\");\n\n    if (pub.getOption(\"logDateEnable\")) {\n      consoleText += currentDate.toISOString().grey + \" - \";\n    }\n\n    switch (level) {\n      case \"debug\":\n        consoleText += \"debug  \".bold.blue;\n        break;\n\n      case \"info\":\n        consoleText += \"info   \".bold.green;\n        break;\n\n      case \"warning\":\n        consoleText += \"warning\".bold.yellow;\n        break;\n\n      case \"error\":\n        consoleText += \"error  \".bold.red;\n        break;\n\n      default:\n        consoleText += level.bold;\n    }\n\n    consoleText += \" - \" + \"EasyRTC: \".bold + logText;\n  } else {\n    if (pub.getOption(\"logDateEnable\")) {\n      consoleText += currentDate.toISOString() + \" - \";\n    }\n\n    consoleText += level;\n    consoleText += \" - \" + \"EasyRTC: \" + logText;\n  }\n\n  if (logFields != undefined && logFields != null) {\n    if (pub.getOption(\"logErrorStackEnable\") && pub.util.isError(logFields)) {\n      console.log(consoleText, pub.getOption(\"logColorEnable\") ? \"\\nStack Trace:\\n------------\\n\".bold + logFields.stack.magenta + \"\\n------------\".bold : \"\\nStack Trace:\\n------------\\n\" + logFields.stack + \"\\n------------\");\n    } else if (pub.getOption(\"logWarningStackEnable\") && pub.util.isWarning(logFields)) {\n      console.log(consoleText, pub.getOption(\"logColorEnable\") ? \"\\nStack Trace:\\n------------\\n\".bold + logFields.stack.cyan + \"\\n------------\".bold : \"\\nStack Trace:\\n------------\\n\" + logFields.stack + \"\\n------------\");\n    } else {\n      console.log(consoleText, util.inspect(logFields, {\n        colors: pub.getOption(\"logColorEnable\"),\n        showHidden: false,\n        depth: pub.getOption(\"logObjectDepth\")\n      }));\n    }\n  } else {\n    console.log(consoleText);\n  }\n\n  next(null);\n};\n/**\n * Default listener for event \"msgTypeRoomJoin\". This event is fired when an easyrtcCmd message with msgType of \"roomJoin\" is received from a client. \n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Object} rooms          A room object containing a map of room names and room parameters.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onMsgTypeRoomJoin = function (connectionObj, rooms, socketCallback, next) {\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appObj = connectionObj.getApp();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onMsgTypeRoomJoin'\");\n\n  if (!_.isFunction(socketCallback)) {\n    pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC info: unhandled socket message callback.\");\n    return;\n  }\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  if (!_.isObject(rooms) || _.isEmpty(rooms)) {\n    pub.events.emit(\"emitReturnError\", socketCallback, \"MSG_REJECT_BAD_STRUCTURE\", pub.util.nextToNowhere);\n    return;\n  }\n\n  for (var currentRoomName in rooms) {\n    if (!_.isString(currentRoomName) || !connectionObj.getApp().getOption(\"roomNameRegExp\").test(currentRoomName)) {\n      pub.events.emit(\"emitReturnError\", socketCallback, \"MSG_REJECT_TARGET_ROOM\", pub.util.nextToNowhere);\n      return;\n    }\n  }\n\n  async.each(Object.keys(rooms), function (currentRoomName, roomCallback) {\n    appObj.isRoom(currentRoomName, function (err, isRoom) {\n      // Set roomParameter map. This may be used by custom listeners.\n      var currentRoomParameter;\n\n      if (rooms[currentRoomName] && _.isObject(rooms[currentRoomName].roomParameter)) {\n        currentRoomParameter = rooms[currentRoomName].roomParameter;\n      }\n\n      if (isRoom) {\n        pub.events.emit(\"roomJoin\", connectionObj, currentRoomName, currentRoomParameter, roomCallback);\n      } else if (appObj.getOption(\"roomAutoCreateEnable\")) {\n        pub.events.emit(\"roomCreate\", appObj, connectionObj, currentRoomName, null, function (err, roomObj) {\n          if (err) {\n            roomCallback(err);\n            return;\n          }\n\n          pub.events.emit(\"roomJoin\", connectionObj, currentRoomName, currentRoomParameter, roomCallback);\n        });\n      } else {\n        pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"][\" + currentRoomName + \"] Unable to join non-existent room.\");\n        roomCallback(new pub.util.ConnectionError(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"][\" + currentRoomName + \"] Unable to join room.\"));\n      }\n    });\n  }, function (err, newRoomObj) {\n    if (err) {\n      pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_BAD_ROOM\"), appObj);\n      next(null); // Error has been handled\n\n      return;\n    }\n\n    connectionObj.generateRoomClientList(\"join\", rooms, function (err, roomData) {\n      if (err) {\n        pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_BAD_ROOM\"), appObj);\n        next(null); // Error has been handled\n      } else {\n        pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, {\n          \"msgType\": \"roomData\",\n          \"msgData\": {\n            \"roomData\": roomData\n          }\n        }, appObj);\n      }\n    });\n  });\n};\n/**\n * Default listener for event \"msgTypeRoomLeave\". This event is fired when an easyrtcCmd message with msgType of \"roomLeave\" is received from a client. \n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Object} rooms          A room object containing a map of room names.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onMsgTypeRoomLeave = function (connectionObj, rooms, socketCallback, next) {\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appObj = connectionObj.getApp();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onMsgTypeRoomLeave' with rooms: \", rooms);\n\n  if (!_.isFunction(socketCallback)) {\n    socketCallback = function (returnMsg) {\n      pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC info: unhandled ACK return message.\", returnMsg);\n    };\n  }\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  } // Loop through each room in the rooms object. Emit the leaveRoom event for each one.\n\n\n  async.each(Object.keys(rooms), function (currentRoomName, asyncCallback) {\n    connectionObj.events.emit(\"roomLeave\", connectionObj, currentRoomName, function (err) {\n      if (err) {\n        pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Error leaving room [\" + currentRoomName + \"].\", err);\n      }\n\n      asyncCallback(null);\n    });\n  }, function (err, newRoomObj) {\n    var roomData = {};\n\n    for (var currentRoomName in rooms) {\n      roomData[currentRoomName] = {\n        \"roomName\": currentRoomName,\n        \"roomStatus\": \"leave\"\n      };\n    }\n\n    pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, {\n      \"msgType\": \"roomData\",\n      \"msgData\": {\n        \"roomData\": roomData\n      }\n    }, appObj);\n    next(null);\n  });\n};\n/**\n * Default listener for event \"msgTypeGetIceConfig\". This event is fired when an easyrtcCmd message with msgType of \"getIceConfig\" is received from a client. \n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onMsgTypeGetIceConfig = function (connectionObj, socketCallback, next) {\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appObj = connectionObj.getApp();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onMsgTypeGetIceConfig'\");\n\n  if (!_.isFunction(socketCallback)) {\n    socketCallback = function (returnMsg) {\n      pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC info: unhandled ACK return message.\", returnMsg);\n    };\n  }\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  connectionObj.events.emit(\"getIceConfig\", connectionObj, function (err, iceConfigObj) {\n    if (err) {\n      pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_GEN_FAIL\"), appObj);\n    } else {\n      pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, {\n        \"msgType\": \"iceConfig\",\n        \"msgData\": {\n          \"iceConfig\": {\n            \"iceServers\": iceConfigObj\n          }\n        }\n      }, appObj);\n    }\n\n    next(null);\n  });\n};\n/**\n * Default listener for event \"msgTypeGetRoomList\". This event is fired when an easyrtcCmd message with msgType of \"getRoomList\" is received from a client. \n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onMsgTypeGetRoomList = function (connectionObj, socketCallback, next) {\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appObj = connectionObj.getApp();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onMsgTypeGetRoomList'\");\n\n  if (!_.isFunction(socketCallback)) {\n    socketCallback = function (returnMsg) {\n      pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC info: unhandled ACK return message.\", returnMsg);\n    };\n  }\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  connectionObj.generateRoomList(function (err, roomList) {\n    if (err) {\n      pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_NO_ROOM_LIST\"), appObj);\n    } else {\n      pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, {\n        \"msgType\": \"roomList\",\n        \"msgData\": {\n          \"roomList\": roomList\n        }\n      }, appObj);\n    }\n\n    next(null);\n  });\n};\n/**\n * Default listener for event \"msgTypeSetPresence\". This event is fired when an easyrtcCmd message with msgType of \"setPresence\" is received from a client. \n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Object} presenceObj    Presence object which contains all the fields for setting a presence for a connection.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onMsgTypeSetPresence = function (connectionObj, presenceObj, socketCallback, next) {\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appObj = connectionObj.getApp();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onMsgTypeSetPresence' with setPresence: \", presenceObj);\n\n  if (!_.isFunction(socketCallback)) {\n    socketCallback = function (returnMsg) {\n      pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC info: unhandled ACK return message.\", returnMsg);\n    };\n  }\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  connectionObj.setPresence(presenceObj, function (err) {\n    if (err) {\n      pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_PRESENCE\"), appObj);\n    } else {\n      connectionObj.emitRoomDataDelta(false, function (err, roomDataObj) {\n        if (err) {\n          pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_PRESENCE\"), appObj);\n        } else {\n          pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, {\n            \"msgType\": \"roomData\",\n            \"msgData\": {\n              \"roomData\": roomDataObj\n            }\n          }, appObj);\n        }\n      });\n    }\n\n    next(null);\n  });\n};\n/**\n * Default listener for event \"msgTypeSetRoomApiField\". This event is fired when an easyrtcCmd message with msgType of \"setRoomApiField\" is received from a client. \n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Object} roomApiFieldObj Api Field object which contains all the fields for setting a presence for a connection.\n * @param       {Function} socketCallback Socket.io callback function which delivers a response to a socket. Expects a single parameter (msg).\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onMsgTypeSetRoomApiField = function (connectionObj, roomApiFieldObj, socketCallback, next) {\n  var easyrtcid = connectionObj.getEasyrtcid();\n  var appObj = connectionObj.getApp();\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onMsgTypeSetRoomApiField' with apiFieldObj: \", roomApiFieldObj);\n\n  if (!_.isFunction(socketCallback)) {\n    socketCallback = function (returnMsg) {\n      pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] EasyRTC info: unhandled ACK return message.\", returnMsg);\n    };\n  }\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  connectionObj.room(roomApiFieldObj.roomName, function (err, connectionRoomObj) {\n    if (err) {\n      pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_BAD_ROOM\"), appObj);\n      next(null);\n      return;\n    }\n\n    connectionRoomObj.setApiField(roomApiFieldObj.field, function (err) {\n      if (err) {\n        pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_BAD_FIELD\"), appObj);\n        next(null);\n        return;\n      }\n\n      connectionRoomObj.emitRoomDataDelta(false, function (err, roomDataDelta) {\n        if (err) {\n          pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, pub.util.getErrorMsg(\"MSG_REJECT_GEN_FAIL\"), appObj);\n          next(null);\n          return;\n        }\n\n        var msg = {\n          \"msgType\": \"roomData\",\n          \"msgData\": {\n            \"roomData\": {}\n          }\n        };\n        msg.msgData.roomData[roomApiFieldObj.roomName] = roomDataDelta;\n        pub.util.sendSocketCallbackMsg(easyrtcid, socketCallback, msg, appObj);\n      });\n    });\n  });\n};\n/**\n * Default listener for event \"getIceConfig\". Returns an ICE configuration object to the callback.\n * \n * The ICE configuration object will hold the array of STUN and TURN servers the connection should use when forming a peer connection. This default listener uses the \"appIceServers\" configuration option at the application level.\n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {Function} callback     Callback of form (err, iceConfigArray)\n */\n\n\neventListener.onGetIceConfig = function (connectionObj, callback) {\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onGetIceConfig'\");\n  callback(null, connectionObj.getApp().getOption(\"appIceServers\"));\n};\n/**\n * Default listener for event \"roomCreate\". Creates a room attached to an application with a specified room name. The optional creatorConnectionObj is provided to provide context; joining the room is done separately. If successful, the callback returns a roomObj.\n * \n * @param       {Object} appObj         EasyRTC application object. Contains methods used for identifying and managing an application.\n * @param       {?Object} creatorConnectionObj EasyRTC connection object belonging to the creator of the room. Contains methods used for identifying and managing a connection.\n * @param       {string} roomName       Room name which uniquely identifies a room within an EasyRTC application.\n * @param       {?Object} roomOptions   Sets room level options. May be null or map of key/value pairs.\n * @param       {Function} callback     Callback of form (err, roomObj)\n */\n\n\neventListener.onRoomCreate = function (appObj, creatorConnectionObj, roomName, roomOptions, callback) {\n  pub.util.logDebug(\"[\" + appObj.getAppName() + \"]\" + (creatorConnectionObj ? \"[\" + creatorConnectionObj.getEasyrtcid() + \"]\" : \"\") + \" Room [\" + roomName + \"] Running func 'onRoomCreate'\");\n  appObj.createRoom(roomName, roomOptions, callback);\n};\n/**\n * Default listener for event \"roomJoin\". Joins a connection to a a specified room. If successful, the callback will return a connectionRoomObj.\n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {string} roomName       Room name which uniquely identifies a room within an EasyRTC application.\n * @param       {?Object} roomParameter A map(dictionary) object with key/value pairs. The values can be any JSONable object. This field is not currently looked at by EasyRTC, however it is available for custom server applications. May be used for room options or authentication needs.\n * @param       {Function} callback     Callback of form (err, connectionRoomObj)\n */\n\n\neventListener.onRoomJoin = function (connectionObj, roomName, roomParameter, callback) {\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onRoomJoin'\"); // roomParameter is a new field. To ease upgrading we'll just show a warning to server applications which haven't updated \n\n  if (_.isFunction(roomParameter)) {\n    pub.util.logWarning(\"Upgrade notice: EasyRTC roomJoin event called without roomParameter object.\");\n    callback = roomParameter;\n    roomParameter = null;\n  }\n\n  connectionObj.joinRoom(roomName, function (err, connectionRoomObj) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    connectionRoomObj.emitRoomDataDelta(false, function (err, roomDataDelta) {\n      // Return connectionRoomObj regardless of if there was a problem sending out the deltas\n      callback(null, connectionRoomObj);\n    });\n  });\n};\n/**\n * Default listener for event \"roomLeave\". Run upon a connection leaving a room.\n * \n * @param       {Object} connectionObj  EasyRTC connection object. Contains methods used for identifying and managing a connection.\n * @param       {string} roomName       Room name which uniquely identifies a room within an EasyRTC application.\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onRoomLeave = function (connectionObj, roomName, next) {\n  pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Running func 'onRoomLeave' with rooms [\" + roomName + \"]\");\n\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  connectionObj.room(roomName, function (err, connectionRoomObj) {\n    if (err) {\n      pub.util.logWarning(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Couldn't leave room [\" + roomName + \"]\");\n      next(err);\n      return;\n    }\n\n    pub.util.logDebug(\"[\" + connectionObj.getAppName() + \"][\" + connectionObj.getEasyrtcid() + \"] Leave room [\" + roomName + \"]\");\n    connectionRoomObj.leaveRoom(next);\n  });\n};\n/**\n * Default listener for event \"shutdown\". This event is fired when the server is being shutdown.\n * \n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onShutdown = function (next) {\n  pub.util.logDebug(\"Running func 'onShutdown'\");\n  next(null);\n};\n/**\n * Default listener for event \"startup\". This event initializes EasyRTC server so it is ready for connections.\n *\n * @param       {nextCallback} next     A success callback of form next(err).\n */\n\n\neventListener.onStartup = function (next) {\n  if (!_.isFunction(next)) {\n    next = pub.util.nextToNowhere;\n  }\n\n  pub.util.logDebug(\"Running func 'onStartup'\");\n  async.waterfall([function (callback) {\n    pub.util.logDebug(\"Configuring Http server\"); // Set the EasyRTC demos\n\n    if (pub.getOption(\"demosEnable\")) {\n      pub.util.logDebug(\"Setting up demos to be accessed from '\" + pub.getOption(\"demosPublicFolder\") + \"/'\");\n      pub.httpApp.get(pub.getOption(\"demosPublicFolder\") + \"/*\", function (req, res) {\n        (res.sendFile || res.sendfile).call(res, \"./demos/\" + (req.params[0] ? req.params[0] : \"index.html\"), // TODO security check\n        {\n          root: __dirname + \"/../\"\n        }, function (err) {\n          try {\n            if (err && err.status && res && !res._headerSent) {\n              res.status(404);\n              var body = \"<html><head><title>File Not Found</title></head><body><h1>File Not Found</h1></body></html>\";\n              res.setHeader(\"Content-Type\", \"text/html\");\n              res.setHeader(\"Content-Length\", body.length);\n              res.end(body);\n            }\n          } catch (e) {}\n        });\n      }); // Forward people who forget the trailing slash to the folder.\n\n      pub.httpApp.get(pub.getOption(\"demosPublicFolder\"), function (req, res) {\n        res.redirect(pub.getOption(\"demosPublicFolder\") + \"/\");\n      });\n    }\n\n    if (pub.getOption(\"apiEnable\")) {\n      // Set the EasyRTC API files\n      pub.util.logDebug(\"Setting up API files to be accessed from '\" + pub.getOption(\"apiPublicFolder\") + \"/'\");\n      pub.httpApp.get(pub.getOption(\"apiPublicFolder\") + \"/easyrtc.js\", function (req, res) {\n        pub.util.sendSessionCookie(req, res);\n        (res.sendFile || res.sendfile).call(res, \"api/easyrtc.js\", {\n          root: __dirname + \"/../\"\n        });\n      });\n      pub.httpApp.get(pub.getOption(\"apiPublicFolder\") + \"/easyrtc_ft.js\", function (req, res) {\n        pub.util.sendSessionCookie(req, res);\n        (res.sendFile || res.sendfile).call(res, \"api/easyrtc_ft.js\", {\n          root: __dirname + \"/../\"\n        });\n      });\n      pub.httpApp.get(pub.getOption(\"apiPublicFolder\") + \"/easyrtc.css\", function (req, res) {\n        pub.util.sendSessionCookie(req, res);\n        (res.sendFile || res.sendfile).call(res, \"api/easyrtc.css\", {\n          root: __dirname + \"/../\"\n        });\n      });\n      pub.httpApp.get(pub.getOption(\"apiPublicFolder\") + \"/easyrtc.min.js\", function (req, res) {\n        pub.util.sendSessionCookie(req, res);\n        (res.sendFile || res.sendfile).call(res, \"open_source/api/easyrtc.min.js\", {\n          root: __dirname + \"/../\"\n        });\n      });\n      pub.httpApp.get(pub.getOption(\"apiPublicFolder\") + \"/easyrtc_ft.min.js\", function (req, res) {\n        pub.util.sendSessionCookie(req, res);\n        (res.sendFile || res.sendfile).call(res, \"api/easyrtc_ft.min.js\", {\n          root: __dirname + \"/../\"\n        });\n      });\n      pub.httpApp.get(pub.getOption(\"apiPublicFolder\") + \"/easyrtc.min.css\", function (req, res) {\n        pub.util.sendSessionCookie(req, res);\n        (res.sendFile || res.sendfile).call(res, \"open_source/api/easyrtc.min.css\", {\n          root: __dirname + \"/../\"\n        });\n      });\n      pub.httpApp.get(pub.getOption(\"apiPublicFolder\") + \"/img/*\", function (req, res) {\n        pub.util.sendSessionCookie(req, res);\n        (res.sendFile || res.sendfile).call(res, \"./api/img/\" + (req.params[0] ? req.params[0] : \"index.html\"), {\n          root: __dirname + \"/../\"\n        }, function (err) {\n          try {\n            if (err && err.status && res && !res._headerSent) {\n              res.status(404);\n              var body = \"<html><head><title>File Not Found</title></head><body><h1>File Not Found</h1></body></html>\";\n              res.setHeader(\"Content-Type\", \"text/html\");\n              res.setHeader(\"Content-Length\", body.length);\n              res.end(body);\n            }\n          } catch (e) {}\n        });\n      });\n\n      if (pub.getOption(\"apiLabsEnable\")) {\n        pub.httpApp.get(pub.getOption(\"apiPublicFolder\") + \"/labs/*\", function (req, res) {\n          pub.util.sendSessionCookie(req, res);\n          (res.sendFile || res.sendfile).call(res, \"./api/labs/\" + (req.params[0] ? req.params[0] : \"index.html\"), {\n            root: __dirname + \"/../\"\n          }, function (err) {\n            try {\n              if (err && err.status && res && !res._headerSent) {\n                res.status(404);\n                var body = \"<html><head><title>File Not Found</title></head><body><h1>File Not Found</h1></body></html>\";\n                res.setHeader(\"Content-Type\", \"text/html\");\n                res.setHeader(\"Content-Length\", body.length);\n                res.end(body);\n              }\n            } catch (e) {}\n          });\n        });\n      }\n    }\n\n    if (pub.getOption(\"apiEnable\") && pub.getOption(\"apiOldLocationEnable\")) {\n      pub.util.logWarning(\"Enabling listening for API files in older depreciated location.\"); // Transition - Old locations of EasyRTC API files\n\n      pub.httpApp.get(\"/js/easyrtc.js\", function (req, res) {\n        (res.sendFile || res.sendfile).call(res, \"api/easyrtc.js\", {\n          root: __dirname + \"/../\"\n        });\n      });\n      pub.httpApp.get(\"/css/easyrtc.css\", function (req, res) {\n        (res.sendFile || res.sendfile).call(res, \"api/easyrtc.css\", {\n          root: __dirname + \"/../\"\n        });\n      });\n    }\n\n    callback(null);\n  }, function (callback) {\n    pub.util.logDebug(\"Configuring Socket server\");\n    pub.socketServer.sockets.on(\"connection\", function (socket) {\n      var easyrtcid = pub.util.getAvailableEasyrtcid();\n      pub.util.logDebug(\"[\" + easyrtcid + \"][\" + socket.id + \"] Socket connected\");\n      pub.util.logDebug(\"Emitting event 'connection'\");\n      pub.events.emit(\"connection\", socket, easyrtcid, function (err) {\n        if (err) {\n          socket.disconnect();\n          pub.util.logError(\"[\" + easyrtcid + \"] Connect error\", err);\n        }\n      });\n    });\n    callback(null);\n  }, // Setup default application\n  function (callback) {\n    pub.createApp(pub.getOption(\"appDefaultName\"), null, callback);\n  }, function (appObj, callback) {\n    // Checks to see if there is a newer version of EasyRTC available\n    if (pub.getOption(\"updateCheckEnable\")) {\n      pub.util.updateCheck();\n    }\n\n    callback(null);\n  }], // This function is called upon completion of the async waterfall, or upon an error being thrown.\n  function (err) {\n    next(err);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}